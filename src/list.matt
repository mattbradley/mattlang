infix left 6 ++

fn :: <T>(element: T, list: EmptyList) -> List<T>
  `List.new([@element])`: List<T>
end

fn :: <T, U>(element: T, list: List<U>) -> List<T | U>
  `List.new([@element] + @list)`: List<T | U>
end

fn hd<T>(list: List<T>) -> T
  `@list.first`: T
end

fn tl<T>(list: List<T>) -> List<T> | EmptyList
  `
    v = List.new(@list[1..-1])
    cast(v, v.empty? ? 'EmptyList' : 'List<T>')
  `: List<T> | EmptyList
end

fn ++ <T>(lhs: List<T>, rhs: EmptyList) -> List<T>
  lhs
end

fn ++ <T>(lhs: EmptyList, rhs: List<T>) -> List<T>
  rhs
end

fn ++ <T, U>(lhs: List<T>, rhs: List<U>) -> List<T | U>
  List.reduce_right(lhs, rhs) { (list: List<T | U>, elem: T) -> elem :: list }
end

module List
  fn is_empty(list: EmptyList) -> Bool; true end
  fn is_empty<T>(list: List<T>) -> Bool; false end

  fn reduce<T, F>(list: EmptyList, acc: T, f: F) -> T
    acc
  end

  fn reduce<T, U, V>(list: List<T>, acc: U, f: (U | V, T) -> V) -> V
    head = hd(list)
    tail = tl(list)
    reduce(tail, f(acc, head), f)
  end

  fn reduce<T, F>(list: EmptyList, f: F) -> Nil
    nil
  end

  fn reduce<T, U>(list: List<T>, f: (T | U, T) -> U) -> T | U
    head = hd(list)
    tail = tl(list)
    reduce(tail, head, f)
  end

  fn reduce_right<T, F>(list: EmptyList, acc: T, f: F) -> T
    acc
  end

  fn reduce_right<T, U, V>(list: List<T>, acc: U, f: (U | V, T) -> V) -> V
    list |> reverse |> reduce(acc, f)
  end

  fn map<T, U>(list: EmptyList, f: T -> U) -> EmptyList; list end
  fn map<T, U>(list: List<T>, f: T -> U) -> List<U>
    reduce(list, []) { (acc: List<U> | EmptyList, x: T) -> f(x) :: acc } |> reverse
  end

  fn each<T, U>(list: EmptyList, f: T -> U) -> Nil; nil end
  fn each<T, U>(list: List<T>, f: T -> U) -> Nil
    head = hd(list)
    tail = tl(list)
    f(head)
    each(tail, f)
  end

  fn reverse(list: EmptyList) -> EmptyList; list end

  fn reverse<T>(list: List<T>) -> List<T>
    reverse(list, [])
  end

  fn reverse(list: EmptyList, tail: EmptyList) -> EmptyList; tail end
  fn reverse<T>(list: EmptyList, tail: List<T>) -> List<T>; tail end
  fn reverse<T>(list: List<T>, tail: EmptyList) -> List<T>
    reverse(tl(list), hd(list) :: tail)
  end
  fn reverse<T, U>(list: List<T>, tail: List<U>) -> List<T | U>
    reverse(tl(list), hd(list) :: tail)
  end

  fn filter<T>(list: EmptyList, f: T -> Bool) -> EmptyList
    []
  end

  fn filter<T>(list: List<T>, f: T -> Bool) -> List<T> | EmptyList
    reduce(list, []) { (acc: List<T> | EmptyList, x: T) ->
      if f(x)
        x :: acc
      else
        acc
      end
    } |> reverse
  end
end

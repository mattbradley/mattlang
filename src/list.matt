infix right 5 ::
infix left 6 ++

fn :: <T, U>(element: T, list: List<U>) -> List<T | U>
  `List.new([@element] + @list)`: List<T | U>
end

fn ++ <T, U>(lhs: List<T>, rhs: List<U>) -> List<T | U>
  List.reduce_right(lhs, rhs) { list, elem -> elem :: list }
end

module List
  fn reduce<T, U>(list: List<T>, acc: U, f: (U, T) -> U) -> U
    case list
      head :: tail -> reduce(tail, f(acc, head), f)
      [] -> acc
    end
  end

  fn reduce_right<T, U>(list: List<T>, acc: U, f: (U, T) -> U) -> U
    list |> reverse |> reduce(acc, f)
  end

  fn head<T>(list: List<T>) -> T | Nil
    case list
      head :: _ -> head
      [] -> nil
    end
  end

  fn tail<T>(list: List<T>) -> List<T> | Nil
    case list
      _ :: tail -> tail
      [] -> nil
    end
  end

  fn count<T>(list: List<T>) -> Int
    reduce(list, 0) { count, _ -> count + 1 }
  end

  fn map<A, B>(list: List<A>, f: A -> B) -> List<B>
    reduce(list, []) { acc, x -> f(x) :: acc } |> reverse
  end

  fn each<T>(list: List<T>, f: T -> Anything) -> Nil
    reduce(list, nil) { _, x -> f(x); nil }
  end

  fn reverse<T>(list: List<T>) -> List<T>
    reduce(list, []) { tail, head -> head :: tail }
  end

  fn filter<T>(list: List<T>, f: T -> Bool) -> List<T>
    reduce(list, []) { acc, x ->
      if f(x)
        x :: acc
      else
        acc
      end
    } |> reverse
  end
end
